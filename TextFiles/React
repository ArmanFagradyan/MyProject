/// Начало 

С его помощью можно создавать одностраничные приложения SPA, реагируют на пользователя и изменяют UI 
Пример: Slack, Google mail, Figma, Facebook, Instagram

* React контролирует использование памяти нашим веб-приложением, реакт декларативен, то есть нужно просто указывать как будет выглядеть каждая часть интерфейса
Императивный - это объяснить как все должно быть сделаоно, чтобы выглядело как нам надо (как?)
Декларативный - это объяснть итоговый результат, то есть не нужно описание каждого шага для достижения результата (что?)

* React основан на повторяющихся компонентах, модульная структура UI components, они компактны и независимы почти как функции.
Использование компонентов позволяют держать чистоты глобального пространства.
Компоненты повторно используемы и легко изменяемы.
Learn once - use everywhere.

* React Native - позволяет создавать нативные приложения 
* React 360 - создание VR приложений

* Внутри React используется препроцессор JSX (помесь JS и HTML).
React также можно использовать нативный JS.

* В React есть алгоритм отслеживания изменения частей приложения и изменения конкретно их (Reconsiliation algorihtm).

* Технология Virtual DOM - легкая копия DOM дерева, в котором мы работаем и уже потом переносим в основное дерево.


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Create React App

* Встроенный сборщик приложения (index.js главный файл, App.js - файл с базовой разметкой, public папка, и еще несколько файлов создается при инициализации, в index.html есть тег noscript и тег div с id = "root" куда будет рендериться наше веб-приложение, package.json, есть встроенный esLint и лучше выключить jsHint, чтобы не ругался).

* Переводом JSX в JS занимается Babel
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Препроцессор JSX 

* В index.js сначала идут импорты React - отвечающий за базовую работу реакта и JSX, ReactDOM - отвечающий за работу с DOM структурой на странице (библиотека позволят вставлять результат работы реакта на страницу, другие сторонние библиотеки, и импорты стилей и функций). 

Пример JSX: const elem = <h2>Hello World!</h2>;

Пример без JSX: const elem = React.createElement('h2', 'null', 'Hello World!'); 
                или const elem = React.createElement('h2', {className: 'greetings'}, 'Hello World!'); 
Первое - название элемента в верстке, Второе - название css классов или null если нет, Третье - содержимое тега. Во втором примере кода Babel не задействуется. Результат второго кода выглядел бы примерно так:

                const elem = {
                    type: 'h2',
                    props: {
                        className: 'greetings',
                        children: 'Hello World!'
                    }
                };

                Вернется вот такой объект.

* Для объемного кода удобнее использовать JSX.
* Нужно ли импортировать React в каждый файл? Нет, после 17 версии импортировать реакт надо только в главный файл index.js.
Первый пример с JSX называется элементом, если в нем есть вложенность то нужно обратить его в круглые скобки. В многострочном элемнте должен быть всегда один родитель, а остальное уже будет вложено в него.
* В настройки Emmet нужно добавить React, чтобы ускорять написание HTML тегов.
* В теги можно вставлять переменные, выражения и все кроме объектов оборачивая их в фигурные скобки:

                const text = 'Hello World!';
                const elem = (
                    <div>
                        <h2>Текст: {text}</h2>
                    </div>
                );

* При работе с index.js HotReload может иногда не срабатывать.
* В React все значения экранируются и переводятся в строки, что помогает избавиться от риска ввода вредоносного скрипта пользователем.
* Атрибуты в геха пишутся в формате camelCase, также есть специальные атрибуты, которые не совпадают с обычными атрибутами, это className, так как class уже зарезервирован за React и атрибут htmlFor, т.к. атрибут for также зарезервирован.
____________________________________________________________________________________________________________________________
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
/// Элементы и компоненты 

* Компоненты это блоки пользовательсокго интерфейса, которые имеют собственное поведение. (Например шапка сайта, подвал сайта)
* Элементы это структурные частички компонентов, а компоненты это уже самостоятельные единицы. Элементы неизменяемы, то есть не можем добавлять, удалять классы или атрибуты, чтобы изменить элементы надо его полностью перерисовать.

React компоненты всегда пишутся с большой буквы, компоненты это функции, которые могут возвращать JSX элементы.
Компоненты это функции, которые могут возвращать JSX элементы и внутри себя могут содержать какое-то поведение.
    
                const Header = () => {  // Это компонент
                    return <h2>Hello World!</h2>    // Это элемент
                }

                const Field = () => {   // Это компонент
                    const holder = 'Enter here';
                    const styledFiled = {
                        width: '300px'
                    }
                    return <input placeholder="Type here" type="text"/>     // Это элемент
                    return <input 
                            placeholder={holder} 
                            type="text" 
                            style={styledField}/>
                }

                function Btn() {  // Это компонент
                    const text = 'Log in'; // Это элемент
                    const res = () => {
                        return 'Log in'
                    }
                    const p = <p>Log in</p> // Это элемент
                    const logged = true;

                    return <button>{text}</button>
                    return <button>{res()}</button>
                    return <button>{p}</button>
                    return <button>{logged ? 'Enter' : text}</button>
                }

                function App() {    // Это компонент
                    return (
                        <div className = "App">
                            <Header/>
                            <Field/>
                            <Btn/>
                        </div>
                    );
                }

                export default App;

                Внутри фигурных скобок вставляемых в выражение нельзя использовать if, пока что можно только использовать теранарные операторы, однако эту логику с if можно прописать отдельно и уже передать результирующую переменную внутри фигурных скобок.

* Мы можем и должны писать компоненты в разных файлах и экспортировать и импортировать в другие файлы для удобного использования, в идеале для каждого компонента должен быть свой файл и уже экспортироваться туда куда он нужен (webpack).

                Пример именного экспорта/импорта:
                
                В файле App.js есть компонент Header и нам нужно экспортировать его в файл index.js
                
                В App.js пишем: export {Header};
                  index.js пишем: import {Header} from './App.js';

* Классы в JS по своей сути являются функциями, значит компоненты реакта могут быть классами, но сейчас идет тренд на функциональные компоненты.Чтобы классы работали правильно, нужно сделать правильное наследование, где каждый последующий потомок наследует что-то от родителя.

                import React from 'react';
                ...
                class Field extends React.Component {

                }

                или 

                import {Component} from 'react';
                ...
                class Field extends Component {
                    render() {                            /// Главный метод
                        const holder = 'Enter here';
                        const styledFiled = {
                            width: '300px'
                        };
                        return <input 
                                placeholder={holder} 
                                type="text" 
                                style={styledField}/>
                    }
                }

                Мы берем базовый компонент из реакта Component и наследуем его особенности в наш созданный класс Field.

* Одним из различий в синтаксисе между Функциональными компонентами и Классовыми компонентами это метод вывода результата, в функциях это return и какое-то выражение где могут быть элементы, компоненты, комбинации, а в классовых компонентах используется метод render() и уже в нем что-то происходит и в конце используется return для возврата какого-либо значения.
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Строгий режим / Strict mode

* Строгий режим очень похож на директиву 'use strict', по сути этот компонент это инструмент для обнаружения потенциальных проблем в приложении, он не рендерит интерфейс, а просто существует внутри реакта, этот компонент может использоваться где угодно. Он активирует доп проверки и предупреждения для своих потомков.

                import React, {StrictMode} from 'react';
                ReactDOM.render(
                    <StrictMode>
                        <App/>
                    </StrictMode>
                    document.getElementById('root')
                );

* Этот компонент помогает обнаружить устаревшие и небезопасные конструкции и сообщает об их эффектах. Например в руки попал старый код и благодаря строгому режиму можно быстро определить проблемный код, Режим работает только в режиме разработчика.
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Свойства компонентов 

* Props - это объект со всеми вещами, которые мы в него передадим.

                function WhoAmI (props) {
                    return (
                        <div>
                            <h1>My name is {props.name}, surname - {props.surname}</h1>
                            <a href={props.link}>My Profile</a>
                        </div>
                    )
                }

                function App() {
                    return (
                        <div className="App">
                            <WhoAmI name="John", surname="Smith", link="facebook.com"/>
                            <WhoAmI name="Alex", surname="Jones", link="vk.com"/>
                        </div>
                    )
                }

В этом примере мы создали комопнент-заготовку, которую потом мы используем заполняя нужными данными. На практике синтаксис используется чаще всего другой, заранее делается деструктуризация props:

                function WhoAmI ({name, surname, link}) {
                    return (
                        <div>
                            <h1>My name is {name}, surname - {surname}</h1>
                            <a href={link}>My Profile</a>
                        </div>
                    )
                }

                function App() {
                    return (
                        <div className="App">
                            <WhoAmI name="John", surname="Smith", link="facebook.com"/>
                            <WhoAmI name="Alex", surname="Jones", link="vk.com"/>
                        </div>
                    )
                }

* В этих примерах, мы передавали атрибуты / пропсы, и они неизменяемы, они идут на чтение, чтобы переделать данные динамически нужно перерисовать весь компонент. Компонент не может изменять свои пропсы, пропсы используем в компоненте, но никогда в них ничего не записываем внутри него же. Состовляющие блоки компонентов это элементы, и когда они были помещены на страницу их уже нельзя изменить, надо будет заново перерисовать компонент. 

* Что именно можно передавать как пропсы? Все что угодно. В следующем примере проп name это объект, и нам нужно свойство из него. Всегда помним, что мы не можем передать сам объект на страницу. Функции тоже могут быть переданы как пропсы.
                ...
                <h1>My name is {name.firstname}, surname - {surname}</h1>
                ...
                <WhoAmI name={{firstname: 'John'}}, surname="Smith", link="facebook.com"/>
                <WhoAmI name={{firstname: 'Alex'}}, surname="Jones", link="vk.com"/>
                ...

                \\\\\\\

                ...
                <h1>My name is {name}, surname - {surname}</h1>
                ...
                <WhoAmI name={() => {return 'John'}}, surname="Smith", link="facebook.com"/>
                <WhoAmI name={() => {return 'Alex'}}, surname="Jones", link="vk.com"/>
                ...
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Работа со списками и алгоритм согласования 

* Работа клиентской части это получить данные, красиво их отрисовать и отправить их на сервер при надобности. Почти всегда есть какой-то массив с данными, из которого мы берем какой-то метод из маассива этих данных и на этой базе будем формировать компоненты, которые пойдут в интерфейс, чаще всего используется метод map, но также иногда используем методы filter и reduce.

* Каждый жлемент массива должен иметь prop(свойство) key. Т.к. в react идет постоянное перерисование, замена и добавление компонентов.

* Алгорит реконсилиации или согласования или просто сверка. 
Допустим у нас есть компонент в корневом элементе которого записывается большое количество других элементов (например список вытянутый из базы данных), и при изменении корнего элемента разрушается все DOM дерево и перерендериться заново, а нам такое не всегда надо, например когда в корневом элементе очень большое количество других элементов. Этот принцип бывает полезен, ведь когда меняется родительский элемент, то будет безопаснее если дочерние элементы тоже перерисуются. Ранее говорилось про изменения тега, а если изменения меняется атрибут, то реакт сохраняет копию предыдущего дерева, но при этом и сохраняет новое дерево, которое должно быть построено благодаря Virtual DOM, далее реакт поочередно сравнивает элементы друг с другом если находятся различия, то изменененные элементы проходят мутацию,и реакт перериросовывает только те элементы, котороые проходят изменения. Реакт проходит по элементам, и вместо старого элемента вставляет новый если находит различия. Сравнение идет по порядку. Допустим мы добаляем элемент в корневой элемент, если он стоит на последнем месте, то он просто пройдется по очереди и вставит его в конце, а если новый элемент встает на первое место, то реакт будет думать, что весь список полностью измнился из-за сбивки нумерации, и следовательно он беднт перерисовывать все элементы. Чтобы это избежать, используется атрибут key. Алгорит реконсилиации нужен для оптимизации работы рпограммы.

* Реакт обновляет элементы, которые действительно изменились, для этого используем атрибут key, чтобы отрабатывал алгорит согласования (реконсилиации).

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Состояние компонентов 

Состояние (State) можно динамически менять. Компоненты бывают функциональные и классовые, раньше нельзя было создать состояние с помощью функциональных компонентов, но потом появились хуки, то есть раньше только классовые компоненты работали с состояниями. 

Как работают пропсы в классовых компонентах. Когда классовый компонент вызывается, он создает свой экземпляр, для этого используется свойсвто constructor в который приходит аргумент props. Возможность работать с пропсами приходит из реакт Компонента. Все поведение наследуется из Component. Пропсы только для чтения.

Как динамически менять данные в компонентах? Пропсы только для чтения. Чтобы создать состояние в конструкторе надо занять новое свойство. Задаем свойство this в конструкторе, чтобы задать состояние.Состояние - это некий объект, описывающий динамически изменяемые части компонента. Напрямую состояние менять мы не можем, для этого нужно использовать команду this.setState. В данном примере показано, что в метод constructor мы записываем динамически изменяемые части компонента, а далее в render мы создаем сам изначальный компонент, который получает какие-то переменные в том числе из конструктора.  


                import { Component } from 'react';

                ...

                class WhoAmI extends Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            years: 27
                        }
                    }

                    nextYear = () => {
                        this.setState({
                            years: this.state.years + 1 // Лучше не использовать инкременты и декременты, выдаст ошибку
                        })
                    }

                    render() {
                        const {name, surname, link} = this.props;
                        return (
                            <div>
                            <button onClick={this.nextYear}>+++</button>   /// Сюда мы передаем название метода, а не его вызов
                                <h1>My name is {name}, surname - {surname}, age - {this.state.years} </h1>
                                <a href={link}>My Profile</a>
                            </div>
                        )
                    }
                }
                ...

Команда setState выполняется асинхронно, и может получиться так, что предыдущее состояние еще не обновилось, а команда уже запустилась. Чтобы избежать, можно передать callback функцию, а не асинхронную. Команда setState работает так, что она изменяет только указанные указанные свойсвтва, а нетронутые свойства останутся такими же. 

                import { Component } from 'react';

                ...

                class WhoAmI extends Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            years: 27,
                            text: '+++'
                        }
                    }

                    nextYear = () => {
                        this.setState(state => ({  // Если выделить саму функцию круглыми скобками, то это будет аналогично записи с использ. return
                            years: state.years + 1 
                        }))
                    }

                    render() {
                        const {name, surname, link} = this.props;
                        return (
                            <div>
                            <button onClick={this.nextYear}>{this.state.text}</button>   /// Сюда мы передаем название метода, а не его вызов
                                <h1>My name is {name}, surname - {surname}, age - {this.state.years} </h1>
                                <a href={link}>My Profile</a>
                            </div>
                        )
                    }
                }
                ...

Итог:
    1) У компонента может быть внутреннее состояние, которое динамически меняется.
    2) Оно может быть как у классовых, так и у функциональных компонентов.
    3) State напрямую менять нельзя, только команду setState.
    4) setState и в целом изменение состояние - это асинхронная операция, так что если нужна точность и последовательность этих данных, то мы должны передавать callback.
    5) В команде setState мы можем менять только те свойства объекта состояния, которые нам нужны, остальные остануться без изменений.

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// События в React, вспоминаем this

Для того чтобы назначить обработчик события в реакте, мы должны прописать событие в качестве аргумента в формате camelCase (Пример: onClick в <button>). В примере ниже мы добавляем обработчик события onInput и мы хотим, чтобы при введении каких=то символов в input они попадали в состояние, т.е. учитывались внутри компонента и выводились в верстку. В реакте change и input работают абсолютно одинакого, поэтому чаще всего используем onChange. Для отмены стандарного поведения браузера можно использовать только event prevent default. addEventListener в react не нужно использовать.

Когда мы передаем метод в обработчик события, мы всегда вначале прописываем this для указания экземпляра класса, все тоже самое происходит и для пропсов и для стейтов, когда мы указываем, что работаем с конкретным экземпляром класса. С обработчиками события все немного сложнее, когда событие срабатывает, то контекст теряется, это происходит потому что функция вызывается внутри другого метода/функции и this становится undefined. Например, если в функции nextYear убрать стрелочную функцию и сделать ее обычной, то выйдет ошибка, потому что функция setState вызывается вунтри nextYear, nextYear вызывается внутри render и в итоге контекст теряется, есть три способа решения этой проблемы (см. после первого примера)ю


                import { Component } from 'react';

                ...

                class WhoAmI extends Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            years: 27,
                            position: ''
                        }
                    }

                    nextYear = () => {
                        this.setState(state => ({  // Если выделить саму функцию круглыми скобками, то это будет аналогично записи с использ. return
                            years: state.years + 1 
                        }))
                    }

                    commitInputChanges = (e) => {
                        console.log(e.target.value); // Т.о. можем узнать у объекта события на каком элементе произошло это событие и его значение. 
                        this.setState({
                            position: e.target.value
                        })
                    }

                    render() {
                        const {name, surname, link} = this.props;
                        const {position, years} = this.state;
                        return (
                            <div>
                            <button onClick={this.nextYear}>+++</button> 
                                <h1>My name is {name}, surname - {surname}, 
                                    age - {years}, 
                                    position - {position} </h1>
                                <a href={link}>My Profile</a>
                                <form>
                                    <span>Введите должность</span>
                                    <input type="text" onChange={this.commitInputChanges}/>
                                </form>
                            </div>
                        )
                    }
                }
                ...

* Первый способ решения через конструкцию bind: 
Смотрим в конструктор, слева обычное свойство, которое будет у экземпляра класса, справа идет обращение к этому методу и мы его биндим к конкретному экземпляру класса. Есть неудобство, что при увеличениее количества методов в классе их всех придется биндить, если они используются в обработчике событий.

                ...

                class WhoAmI extends Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            years: 27,
                            position: ''
                        }
                        this.nextYear = this.nextYear.bind(this);
                    }

                    nextYear() {
                        this.setState(state => ({
                            years: state.years + 1 
                        }))
                    }

* Второй способ решения через использование стрелочной функции (метод полей классов Class Fileds), как в первом примере.

* Третий способ решения через использование анонимной стрелочной функции:
Проблема может возникнуть из-за того, что каждый раз когда будет создаваться компонент, то будет создаваться callback и проблема начнется, если дальше этот колбэк будет передаваться в виде пропса. А если у компонента менятеся пропс, то это заставляет его заного перерисовываться -Ю теряется оптимизация.

Когда вызывается setState то за ним всегда вызывается render, и изменяются только те элементы, которые нужно изменить.

                ...

                class WhoAmI extends Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            years: 27,
                            position: ''
                        }
                    }

                    nextYear() {
                        this.setState(state => ({
                            years: state.years + 1 
                        }))
                    }

                    commitInputChanges = (e) => {
                        console.log(e.target.value); 
                        this.setState({
                            position: e.target.value
                        })
                    }

                    render() {
                        const {name, surname, link} = this.props;
                        const {position, years} = this.state;
                        return (
                            <div>
                            <button onClick={() => this.nextYear()}>+++</button> // <<<<
                                <h1>My name is {name}, surname - {surname}, 
                                    age - {years}, 
                                    position - {position} </h1>
                                <a href={link}>My Profile</a>
                                <form>
                                    <span>Введите должность</span>
                                    <input type="text" onChange={this.commitInputChanges}/>
                                </form>
                            </div>
                        )
                    }
                    ...

Рассмотрим использование аргументов в обработчиках событий:
Далее пример прокидывания аргумента в обработчике событий.

                ...

                class WhoAmI extends Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            years: 27,
                            position: ''
                        }
                    }

                    nextYear = () => {
                        this.setState(state => ({
                            years: state.years + 1 
                        }))
                    }

                    commitInputChanges = (e, color) => {  // <<<<
                        console.log(e.target.value);
                        console.log(color);
                        this.setState({
                            position: e.target.value
                        })
                    }

                    render() {
                        const {name, surname, link} = this.props;
                        const {position, years} = this.state;
                        return (
                            <div>
                            <button onClick={this.nextYear}>+++</button>
                                <h1>My name is {name}, surname - {surname}, 
                                    age - {years}, 
                                    position - {position} </h1>
                                <a href={link}>My Profile</a>
                                <form>
                                    <span>Введите должность</span>
                                    <input type="text" onChange={(e) => this.commitInputChanges(e, 'some color')}/>  // <<<<
                                </form>
                            </div>
                        )
                    }
                    ...

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// React-фрагменты

Если импортировать Fragment и в render заменить оборачивающий div этим фрагментом, то можно избавиться от лишнего div, который иногда может ломать верстку.

Есть второй способ, уже нен надо импортировать фрагмент и можно просто вместо div поставить пустые теги <> </>.

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Семантика и доступность контента 

Полезные ссылки:
    1) Базовая Документация: https://ru.reactjs.org/docs/accessibility.html
    2) Статья про ARIA: http://prgssr.ru/development/ispolzovanie-aria-v-html5.html
    3) Документация по ARIA: https://developer.mozilla.org/ru/docs/Web/Accessibility/ARIA
    4) Про скринридеры: https://ru.wikipedia.org/wiki/Экранное_считывающее_устройство
    5) Доклад про доступность: https://www.youtube.com/watch?v=KAK-WAb9vow&ab_channel=Веб-стандарты
    6) Доклад про семантику: https://www.youtube.com/watch?v=bDYEnNzprzE&ab_channel=Веб-стандарты

* ARIA атрибуты также как и data атрибуты идут исключением в React и прописываются как в обычном JS

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Стили в React. Inline Styles

    ...
    <span className="list-group-item"
        onClick={onToggleProp}
        data-toggle="promo"
        style={{fontSize: 40, color: 'red', WebKitTransition: 'all', msTransition: 'all'}}>{name}</span> <<<<<< пример инлайн стиля
    ...

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Стили в React. CSS & SASS/SCSS

Полезные ссылки:
    1) npm sass: https://www.npmjs.com/package/sass

* Можно просто импортировать обычные css файлы, которые webpack читает, на данный момент less в react не поддерживатся, только SASS. Если просто импортировать файлик sass, то реакт выдаст ошибку. Для этого надо подкачать пакет [ npm i sass --save ]. Если хотим использовать какой-то глобальный файл с переменными, то надо будет постоянно его импортировать в файлы стилей scss. Это особенность дефолтного сборщика в реакте.

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Стили в React. Динамические классы и стили

        ...
        const AppFilter = (props) => {
            const buttonsData = [
                {name: 'all', label: 'Все сотрудники', colored: 'false'},
                {name: 'promo', label: 'На повышение', colored: 'false'},
                {name: 'moreThen1000', label: 'зп больше 1000', colored: 'true'}
            ];

            const buttons = buttonsData.map(({name, label, colored}) => {
                const active = props.filter === name;
                const clazz = active ? 'btn-light' : 'btn-outline-light';
                const style = colored ? {color: 'red'} : null;          <<<<<<<<<<<
                return {
                    <button type="button"
                            className={`btn ${clazz}`}
                            key={name}
                            onClick={() => props.onFilterSelect(name)}
                            style={style}>                              <<<<<<<<<<<
                            {label}
                    </button>
                }
            })
        }
        ...

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Стили в React. Styled Components

Полезные ссылки:
    1) styled-components: https://styled-components.com/
    2) Tagged templates: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#tagged_templates

* Технология CSS in JS. Такой подход существует, но используется по вашему усмотрению. Команда [ npm install --save styled-components ]. Теперь мы можем стилизовать проект в js файлах. 

        import styled from 'styled-components'
        ...
        const Wrapper = styled.div`
            width: 600px;
            margin: 80px auto 0 auto;
        `;

        function App() {
            return (
                <Wrapper>
                    <WhoAmI name='John' surname="Smith" link="facebook.com"/>
                    </WhoAmI name='Alex' surname="Shepard" link="vk.com"/>
                </Wrapper>
            );
        }

* Можно создавать стилизованные компоненты, а потом использовать их вместо ранее употребляемых тегов, для более точной стилизации. 
* Также можно создавать стилизованный компонент, который будет наследовать свойства из другого стилизованного компонента и в него можно будет добавлять или изменять в нем свойства:

        const BigButton = styled(Button)`
        margin: 0 auto;
        width: 245px;
        text-align: center;
        `;

* Стилизованные компоненты поддерживают вложенность, что позволяет не создавать много стилизованных компонентов, а лишь использовать вложенности в нутри нескольких компонентов:

        const EmpItem = styled.div`
            padding: 20px;
            margin-bottom: 15px;
            a {
                display: block;
                margin: 10px 0 10px 0;
                color: black;
            }
            input {
                display: block;
                margin-top: 10px;
            }
        `;

* Стилизованные компоненты также поддерживают собственные пропсы.

* Итоги по технологии CSS in JS:
    1) Инкапсуляуия стилей, теперь нет никаких пересечений, потому что даже названий классов не существует 
    2) Нет необходимости использования методики по типу БЭМ 
    3) Использование пропсов и условий
    4) Браузерные вендорные префиксы ставятся автоматически

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Стили в React. Готовые библиотеки компонентов со стилями

Полезные ссылки:
    1) react-bootstrap: https://react-bootstrap.github.io/
    2) reactstrap: https://reactstrap.github.io/?path=/story/home-installation--page
    3) Material Design: https://mui.com/
    4) CSS-modules: https://habr.com/ru/post/335244/
    5) ant design: https://ant.design/

* Реакт бутстрап позволяет использовать готовые компоненты для более эффективной работы с проектами. Начать надо с установки пакета и дописать --save чтобы сохранить все в зависимостях. 

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Поля классов и static

Полезные ссылки:
    1) Репозиторий разработчиков: https://github.com/tc39/proposals/blob/main/finished-proposals.md
    2) Документация: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/Public_class_fields
    3) Документация static: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes/static

* Это экспериментальный синтаксис, используемый в классовых компонентах. На 21 год это еще не было стандартом языка. Использовали мы это прописывая методы в виде стрелочной функции, для того чтобы за нимим закреплялся контекст вызова и не было ошибок.  

* Еще одной особенностью полей классов можно создавать свойства без использования конструктора. 

* Чтобы использовать методы как в нативном JS надо использовать только статичные методы, либо нативные методы из JS:

        ...
        static onLog = () => {
            console.log('Hello');
        }
        ...

        EmployeesAddForm.onLog();

Тоже самое работает и со свойствами. 
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Что такое API и как работают реальные приложения

Полезные ссылки:
    1) Статья про API: https://habr.com/ru/post/464261/
    2) Репозиторий со ссылками: https://github.com/public-apis/public-apis
    3) an api of ice and fire: https://anapioficeandfire.com/
    4) pokeapi: https://pokeapi.co/
    5) Marvel API: https://developer.marvel.com/
    6) Weather API: https://openweathermap.org/api
    7) News API: https://newsapi.org/

* API - application programming interface. Это набор готовых функций и свойств, которые мы можем использовать.
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// 

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
///