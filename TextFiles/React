/// Начало 

С его помощью можно создавать одностраничные приложения SPA, реагируют на пользователя и изменяют UI 
Пример: Slack, Google mail, Figma, Facebook, Instagram

* React контролирует использование памяти нашим веб-приложением, реакт декларативен, то есть нужно просто указывать как будет выглядеть каждая часть интерфейса
Императивный - это объяснить как все должно быть сделаоно, чтобы выглядело как нам надо (как?)
Декларативный - это объяснть итоговый результат, то есть не нужно описание каждого шага для достижения результата (что?)

* React основан на повторяющихся компонентах, модульная структура UI components, они компактны и независимы почти как функции.
Использование компонентов позволяют держать чистоты глобального пространства.
Компоненты повторно используемы и легко изменяемы.
Learn once - use everywhere.

* React Native - позволяет создавать нативные приложения 
* React 360 - создание VR приложений

* Внутри React используется препроцессор JSX (помесь JS и HTML).
React также можно использовать нативный JS.

* В React есть алгоритм отслеживания изменения частей приложения и изменения конкретно их (Reconsiliation algorihtm).

* Технология Virtual DOM - легкая копия DOM дерева, в котором мы работаем и уже потом переносим в основное дерево.


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Create React App

* Встроенный сборщик приложения (index.js главный файл, App.js - файл с базовой разметкой, public папка, и еще несколько файлов создается при инициализации, в index.html есть тег noscript и тег div с id = "root" куда будет рендериться наше веб-приложение, package.json, есть встроенный esLint и лучше выключить jsHint, чтобы не ругался).

* Переводом JSX в JS занимается Babel
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Препроцессор JSX 

* В index.js сначала идут импорты React - отвечающий за базовую работу реакта и JSX, ReactDOM - отвечающий за работу с DOM структурой на странице (библиотека позволят вставлять результат работы реакта на страницу, другие сторонние библиотеки, и импорты стилей и функций). 

Пример JSX: const elem = <h2>Hello World!</h2>;

Пример без JSX: const elem = React.createElement('h2', 'null', 'Hello World!'); 
                или const elem = React.createElement('h2', {className: 'greetings'}, 'Hello World!'); 
Первое - название элемента в верстке, Второе - название css классов или null если нет, Третье - содержимое тега. Во втором примере кода Babel не задействуется. Результат второго кода выглядел бы примерно так:

                const elem = {
                    type: 'h2',
                    props: {
                        className: 'greetings',
                        children: 'Hello World!'
                    }
                };

                Вернется вот такой объект.

* Для объемного кода удобнее использовать JSX.
* Нужно ли импортировать React в каждый файл? Нет, после 17 версии импортировать реакт надо только в главный файл index.js.
Первый пример с JSX называется элементом, если в нем есть вложенность то нужно обратить его в круглые скобки. В многострочном элемнте должен быть всегда один родитель, а остальное уже будет вложено в него.
* В настройки Emmet нужно добавить React, чтобы ускорять написание HTML тегов.
* В теги можно вставлять переменные, выражения и все кроме объектов оборачивая их в фигурные скобки:

                const text = 'Hello World!';
                const elem = (
                    <div>
                        <h2>Текст: {text}</h2>
                    </div>
                );

* При работе с index.js HotReload может иногда не срабатывать.
* В React все значения экранируются и переводятся в строки, что помогает избавиться от риска ввода вредоносного скрипта пользователем.
* Атрибуты в геха пишутся в формате camelCase, также есть специальные атрибуты, которые не совпадают с обычными атрибутами, это className, так как class уже зарезервирован за React и атрибут htmlFor, т.к. атрибут for также зарезервирован.
____________________________________________________________________________________________________________________________
_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
/// Элементы и компоненты 

* Компоненты это блоки пользовательсокго интерфейса, которые имеют собственное поведение. (Например шапка сайта, подвал сайта)
* Элементы это структурные частички компонентов, а компоненты это уже самостоятельные единицы. Элементы неизменяемы, то есть не можем добавлять, удалять классы или атрибуты, чтобы изменить элементы надо его полностью перерисовать.

React компоненты всегда пишутся с большой буквы, компоненты это функции, которые могут возвращать JSX элементы.
Компоненты это функции, которые могут возвращать JSX элементы и внутри себя могут содержать какое-то поведение.
    
                const Header = () => {  // Это компонент
                    return <h2>Hello World!</h2>    // Это элемент
                }

                const Field = () => {   // Это компонент
                    const holder = 'Enter here';
                    const styledFiled = {
                        width: '300px'
                    }
                    return <input placeholder="Type here" type="text"/>     // Это элемент
                    return <input 
                            placeholder={holder} 
                            type="text" 
                            style={styledField}/>
                }

                function Btn() {  // Это компонент
                    const text = 'Log in'; // Это элемент
                    const res = () => {
                        return 'Log in'
                    }
                    const p = <p>Log in</p> // Это элемент
                    const logged = true;

                    return <button>{text}</button>
                    return <button>{res()}</button>
                    return <button>{p}</button>
                    return <button>{logged ? 'Enter' : text}</button>
                }

                function App() {    // Это компонент
                    return (
                        <div className = "App">
                            <Header/>
                            <Field/>
                            <Btn/>
                        </div>
                    );
                }

                export default App;

                Внутри фигурных скобок вставляемых в выражение нельзя использовать if, пока что можно только использовать теранарные операторы, однако эту логику с if можно прописать отдельно и уже передать результирующую переменную внутри фигурных скобок.

* Мы можем и должны писать компоненты в разных файлах и экспортировать и импортировать в другие файлы для удобного использования, в идеале для каждого компонента должен быть свой файл и уже экспортироваться туда куда он нужен (webpack).

                Пример именного экспорта/импорта:
                
                В файле App.js есть компонент Header и нам нужно экспортировать его в файл index.js
                
                В App.js пишем: export {Header};
                  index.js пишем: import {Header} from './App.js';

* Классы в JS по своей сути являются функциями, значит компоненты реакта могут быть классами, но сейчас идет тренд на функциональные компоненты.Чтобы классы работали правильно, нужно сделать правильное наследование, где каждый последующий потомок наследует что-то от родителя.

                import React from 'react';
                ...
                class Field extends React.Component {

                }

                или 

                import {Component} from 'react';
                ...
                class Field extends Component {
                    render() {                            /// Главный метод
                        const holder = 'Enter here';
                        const styledFiled = {
                            width: '300px'
                        };
                        return <input 
                                placeholder={holder} 
                                type="text" 
                                style={styledField}/>
                    }
                }

                Мы берем базовый компонент из реакта Component и наследуем его особенности в наш созданный класс Field.

* Одним из различий в синтаксисе между Функциональными компонентами и Классовыми компонентами это метод вывода результата, в функциях это return и какое-то выражение где могут быть элементы, компоненты, комбинации, а в классовых компонентах используется метод render() и уже в нем что-то происходит и в конце используется return для возврата какого-либо значения.
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Строгий режим / Strict mode

* Строгий режим очень похож на директиву 'use strict', по сути этот компонент это инструмент для обнаружения потенциальных проблем в приложении, он не рендерит интерфейс, а просто существует внутри реакта, этот компонент может использоваться где угодно. Он активирует доп проверки и предупреждения для своих потомков.

                import React, {StrictMode} from 'react';
                ReactDOM.render(
                    <StrictMode>
                        <App/>
                    </StrictMode>
                    document.getElementById('root')
                );

* Этот компонент помогает обнаружить устаревшие и небезопасные конструкции и сообщает об их эффектах. Например в руки попал старый код и благодаря строгому режиму можно быстро определить проблемный код, Режим работает только в режиме разработчика.
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Свойства компонентов 

* Props - это объект со всеми вещами, которые мы в него передадим.

                function WhoAmI (props) {
                    return (
                        <div>
                            <h1>My name is {props.name}, surname - {props.surname}</h1>
                            <a href={props.link}>My Profile</a>
                        </div>
                    )
                }

                function App() {
                    return (
                        <div className="App">
                            <WhoAmI name="John", surname="Smith", link="facebook.com"/>
                            <WhoAmI name="Alex", surname="Jones", link="vk.com"/>
                        </div>
                    )
                }

В этом примере мы создали комопнент-заготовку, которую потом мы используем заполняя нужными данными. На практике синтаксис используется чаще всего другой, заранее делается деструктуризация props:

                function WhoAmI ({name, surname, link}) {
                    return (
                        <div>
                            <h1>My name is {name}, surname - {surname}</h1>
                            <a href={link}>My Profile</a>
                        </div>
                    )
                }

                function App() {
                    return (
                        <div className="App">
                            <WhoAmI name="John", surname="Smith", link="facebook.com"/>
                            <WhoAmI name="Alex", surname="Jones", link="vk.com"/>
                        </div>
                    )
                }

* В этих примерах, мы передавали атрибуты / пропсы, и они неизменяемы, они идут на чтение, чтобы переделать данные динамически нужно перерисовать весь компонент. Компонент не может изменять свои пропсы, пропсы используем в компоненте, но никогда в них ничего не записываем внутри него же. Состовляющие блоки компонентов это элементы, и когда они были помещены на страницу их уже нельзя изменить, надо будет заново перерисовать компонент. 

* Что именно можно передавать как пропсы? Все что угодно. В следующем примере проп name это объект, и нам нужно свойство из него. Всегда помним, что мы не можем передать сам объект на страницу. Функции тоже могут быть переданы как пропсы.
                ...
                <h1>My name is {name.firstname}, surname - {surname}</h1>
                ...
                <WhoAmI name={{firstname: 'John'}}, surname="Smith", link="facebook.com"/>
                <WhoAmI name={{firstname: 'Alex'}}, surname="Jones", link="vk.com"/>
                ...

                \\\\\\\

                ...
                <h1>My name is {name}, surname - {surname}</h1>
                ...
                <WhoAmI name={() => {return 'John'}}, surname="Smith", link="facebook.com"/>
                <WhoAmI name={() => {return 'Alex'}}, surname="Jones", link="vk.com"/>
                ...
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Работа со списками и алгоритм согласования 

* Работа клиентской части это получить данные, красиво их отрисовать и отправить их на сервер при надобности. Почти всегда есть какой-то массив с данными, из которого мы берем какой-то метод из маассива этих данных и на этой базе будем формировать компоненты, которые пойдут в интерфейс, чаще всего используется метод map, но также иногда используем методы filter и reduce.

* Каждый жлемент массива должен иметь prop(свойство) key. Т.к. в react идет постоянное перерисование, замена и добавление компонентов.

* Алгорит реконсилиации или согласования или просто сверка. 
Допустим у нас есть компонент в корневом элементе которого записывается большое количество других элементов (например список вытянутый из базы данных), и при изменении корнего элемента разрушается все DOM дерево и перерендериться заново, а нам такое не всегда надо, например когда в корневом элементе очень большое количество других элементов. Этот принцип бывает полезен, ведь когда меняется родительский элемент, то будет безопаснее если дочерние элементы тоже перерисуются. Ранее говорилось про изменения тега, а если изменения меняется атрибут, то реакт сохраняет копию предыдущего дерева, но при этом и сохраняет новое дерево, которое должно быть построено благодаря Virtual DOM, далее реакт поочередно сравнивает элементы друг с другом если находятся различия, то изменененные элементы проходят мутацию,и реакт перериросовывает только те элементы, котороые проходят изменения. Реакт проходит по элементам, и вместо старого элемента вставляет новый если находит различия. Сравнение идет по порядку. Допустим мы добаляем элемент в корневой элемент, если он стоит на последнем месте, то он просто пройдется по очереди и вставит его в конце, а если новый элемент встает на первое место, то реакт будет думать, что весь список полностью измнился из-за сбивки нумерации, и следовательно он беднт перерисовывать все элементы. Чтобы это избежать, используется атрибут key. Алгорит реконсилиации нужен для оптимизации работы рпограммы.

* Реакт обновляет элементы, которые действительно изменились, для этого используем атрибут key, чтобы отрабатывал алгорит согласования (реконсилиации).

____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
/// Состояние компонентов 

Состояние (State) можно динамически менять. Компоненты бывают функциональные и классовые, раньше нельзя было создать состояние с помощью функциональных компонентов, но потом появились хуки, то есть раньше только классовые компоненты работали с состояниями. 

Как работают пропсы в классовых компонентах. Когда классовый компонент вызывается, он создает свой экземпляр, для этого используется свойсвто constructor в который приходит аргумент props. Возможность работать с пропсами приходит из реакт Компонента. Все поведение наследуется из Component. 

Как динамически менять данные в компонентах? Пропсы только для чтения. Чтобы создать состояние в конструкторе надо занять новое свойство. Задаем свойство this в конструкторе, чтобы задать состояние. Напрямую состояние менять мы не можем, для этого нужно использовать команду this.setState. Команда setState работает асинхронно, что может вызвать неправильную работу. Чтобы избежать, можно передать callback функцию, а не асинхронную

                import { Component } from 'react';

                ...

                class WhoAmI extends Component {
                    constructor(props) {
                        super(props);
                        this.state = {
                            years: 27
                        }
                    }

                    nextYear = () => {
                        this.setState({
                            years: this.state.years + 1 // Лучше не использовать инкременты и декременты, выдаст ошибку
                        })
                    }

                    render() {
                        const {name, surname, link} = this.props;
                        return (
                            <div>
                            <button onClick={this.nextYear}>+++</button>   /// Сюда мы передаем название метода, а не его вызов
                                <h1>My name is {name}, surname - {surname}, age - {this.state.years} </h1>
                                <a href={link}>My Profile</a>
                            </div>
                        )
                    }
                }
                ...
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________


____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________
____________________________________________________________________________________________________________________________