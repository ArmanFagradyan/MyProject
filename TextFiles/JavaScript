/// 3 способа задать перменные

  1) var leftBorderWidth = 1;
  2) let second = 2;
  3) const pi = 3.14;


*  var - предупреждает что сейчас будет переменная
   'Name' - дальше идет имя перменной
   var сущетсвует везде в коде и даже до того как она добалена

*  let начинает сущетсвовать только после того как до него доходит код 

* const работает аналогично с let, так же он задает константу,
    которую можно изменить только особыми обходными путями

* сайт caniuse.com для проверки совместимости новых стандартов с различными браузерами.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Типы данных и их классификация 

см. DataTypes.jpg в файлах

1) число
2) строка
3) символ
4) логические типыданных (true/false)
5) null
6) undefined 
7) Symbol
8) BigInt

* числа могут быть целыми и дробными, а также специальные 
числовые значения (infinity это при деление на ноль) и 
not a number (операция не подлежит математической логике)
 
* null это когда чего-то в коде вообще не сущестует 
undefined это когда какой-либо объект существует но не имеет значения.

* BigInt - тип данных для работы с большими числами.

* obj - это коллекция данных, структура которая используется 
для хранения любых данных, в нем могут содеражться все вышеприведенные
типы данных (он комплексный). Внутри фигурных скобок находится 
Свойство (или Метод). Методы - это функции, т.е. действия которые 
может выполнять объект.

* чтобы вытянуть значение свойсвта используем точку или квадратные скобки.

* массивы используются для хранения данных, которые идут по порядку, 
он заключается в квадратные скобки и построен так, что каждому значению
автоматически присваивается порядковый номер. Массив - это частный случай Объекта.

    let arr = ['plum.png', 'orange.jpg' , 'apple.bmp'];
    console.log(arr[2]);

нумерация в массиве начинается с 0. В консоли при выводе пишем порядковый
номер элемента массива.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Простое общение с пользователем 

* Основаня команда разработчиков это console.log

* Всплывает окно с подтверждением и ответ выводится в консоль.

    let answere = confirm("Are you here?");
    console.log(answere);


* Всплывает окно с полем ввода, и ответ выводится в консоль. При постановке + перед prompt полученное значение от пользователся будет являться не строкой, числом. 

    let answere = prompt("Are you over 18?", "Yes");
    console.log(answere);

* Всплывает окно с полем ввода, но в консоль в любом случае название
типа данных, находящихся в скобках.

    let answere = prompt("Are you over 18?", "Yes");
    console.log(typeof(answere));



___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Интерполяция (ES6)

* Интерполяция - вставка переменных в строки, для этого используем косые ковычки вместо обычных кавычек.

    const category = 'toys';
    console.log(`https://someurl.com/${category}/5/yoyo`);

    const user = 'Arman';
    alert(`Привет, ${user}`);

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Операторы в JS 

(сложение, вычитание, умножение, деление)

* конкатенация для оператора СЛОЖЕНИЯ 
строка + строка = строка  
строка + число = строка 

* унарный + перед prompt меняет строку на число 

    let answere = +prompt("Are you over 18?", "Yes");

* префиксная форма добавления + выдает измененное значение, а 
постфиксная форма выдает старое значние и только потом меняет его

    log.console(++incr);
    log.console(--decr); 

    //

    log.console(incr++);
    log.console(decr--):


* Оператор % выдает остаток от деления чисел 

    log.console(5%2);

* Оператор =

    = это присваивание 
    == проверка на равенство (сравнивет по значениям)
    === строгая проверка по типам данных 

* И и ИЛИ 

    && - два амперсанта показывают пересечение (-И-)
    || - две вертикальные полосы показывают сложение (-ИЛИ-) 
Немного про применение данных операторов: например можем 
проверить отмечены ли оба чекбокса итд. 

* Оператор ОТРИЦАНИЕ

    ! - например console.log(ab || !dr) будет искать пересечение
        значения ab и обратного значения dr.

* Порядок выполнения операций (приоритет операторов)

см. https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

директива usestrict говорит о том, что мы используем стандарт ES6
и некоторые ошибки прошлого работать не будут

* Также существуют Побитовые операторы:
см. https://learn.javascript.ru/bitwise-operators


___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Контроль версий Git и репозиторий GitHub

* Git - э то система контроля версий а GitHub - это удаленное хранилище репозиториев. 
    обучение гиту: https://githowto.com/ru
    документация по гиту: https://git-scm.com/book/ru/v2
    интерактивное обучение гиту: https://learngitbranching.js.org/?locale=ru_RU

* Подключить Git к папке с работой, чтобы он следил за ней, можно использовав в терминале команду git init 

* Чтобы как-то себя авторизовать в git, для того чтобы тебя могли определить другие пользователи репозиторием 
нужна команда 

    git config --global user.name "Name" 
    git config --global user.email email

данный вариант устанавливает имя и почту глобально для всего компьютера, а чтобы сделать это локально надо поменять 
--global  на --local           

* Команда git status показывает статус гита, то есть за какими файлами он следит
* Команда git add -A добавляет все файлы (-А от слова All)

* Используем команду git commit -a -m"Commit message" которая создает так называемую контрольную точку -а говорит, что коммитим все файлы 
-m означает message, т.е. после него в ковычках пишем содержательное сообщение касательно первого коммита.

* Команда git log показывает историю коммитов 

* Сервис GitHub позволяет хранить наши репозитории на сервере, чтобы это было в общем доступе и можно было это использовать вслучаях когда
локальное сохранение потеряно. 

* Используем команду git push чтобы отправить изменения в репозиторий в GitHub 

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Как можно работать с GitHub  с разных компьютеров, gitignore, GitKraken 

* Чтобы скопировать репозиторий и перенсти его в свою папку, создаем в общей своей папке новую папку, потом через терминал выходим из 
текущей папки с помощью команды cd .. дальше также через терминал заходим в новую, соданную нами папку, с помощью команды cd name (имя новой папки).
После этого копируем через GitHub ссылку на нужный репозиторий и прописываем команду git clone "скопированны адрес" "Задаем имя папке".

Команда git pull переносит изменения сделанные в репозитории с одного пк на свой пк.

* файл .gitignore нужен для того чтобы определные файлы не пушились в GitHub, например если это очень большие файлы и их нецелесообразно пушить или
пулить через терминал. 

* GitKraken - софт для удобной работы с репозиториями 

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Условия 

Условия - это принципы помогающие пустить программу или действия по правильному пути

* Пример 1:

        let num = 50;

        if (num < 49) {
            console.log("Not right");
        } else if (num > 100) {
            console.log("Too much");
        } else {
            console.log("Right");

В круглых скобках указывается нужное нам условие, а в фигурных скобках указываем то действие, которое должно быть выполнено при соблюдении условия.
После else указываем альтернативное условие по той же системе.

* Пример 2:

        (num == 50) ? console.log('Right'): console.log('Wrong');

Это запись в виде тернарного оператора. Внутри круглых скобок условие, потом вопросительный знак и действие, которое должно выполниться, а дальше дейтсвие,
которое выполниться если условие не верно.


* Пример 3:

        switch (num) {
            case num < 49:
                console.log('Right');
                break;
            case num > 100:
                console.log('Too much');
                break;
            case num > 80:
                console.log('Still too much');
                break;
            case 50:
                console.log('Right');
                break;
            default:
                console.log('Something went wrong');
        }

Это практичная модификация для if. В первых скобках пишем то, что будем проверять, в фигурных скобках пишем проверки, т.е. начинаем с case и пишем условие,
потом после двоеточия пишем дейтсвие, которое должно выполниться при условии. После этого ставим break, эта директива нужна, чтобы цикл завершился, если  
условие выполнилось. При проверке на реальное значение, пишем просто само значение(т.е. без переменной). Есть структура default, она нужна, когда ни одно 
из условий выше не выполнилось. 

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Циклы 

Циклы - это главный элемент автоматизации. 

* Есть три цикла:

* Первый пример: 

        let num = 50;

        while (num < 55) {
            console.log(num);
            num++;
        }
В курглых скобках пишем условие. В фигурных скобках пишем порядок действий.

* Второй пример:

        let num = 50;

        do {
            console.log(num);
            num++;
        }
        while (num < 55);
В данном случае конструкция сначала призывает к дейтсвию, а лишь потом пишем до каких пор должен выполняться набор дейтсвий.

* Третий пример: 

        for (let i = 1; i < 8; i++) {
            if (i == 6) {
                break;
            }
            console.log(i);
        }


        for (let i = 1; i < 8; i++) {
            if (i == 6) {
                continue;
            }
            console.log(i);
        }
Используется чаще всего. В скобках, сначала задаем переменную или просто пишем переменную, после точки с запятой пишем условие,
далее после точки с запятой пишем действие, которое должно быть выполнено, пока не выполнено условие. В фигурных скобках пишем действия.
Нужно быть осторожным с циклом, чтобы не появился бесконечный цикл, который заставит все зависнуть. Директива break так же может 
быть использована для прерывания цикла. Директива continue позволяет пропустить один шаг в дейтсвии, то есть перрывается одна итерация цикла.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Функции 

Полезные ссылки: 
        1) Про замыкание функций https://medium.com/nuances-of-programming/я-никогда-не-понимал-замыкания-в-javascript-часть-первая-3c3f02041970  
        2) Про метод строк  https://learn.javascript.ru/string  
        3) Про метод чисел https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number   

Если по простому, то функции это наши действия в JS. Они используют различные типы данных и изменяют информацию так, как мы укажем. 
Для того чтобы задать функцию, пишем: function, затем пишем имя нашей новой функции, открываем круглые скобки для аргументов фукнции,
и дальше в фигурных скобках пишем то,что будет выполняться. 
Имя функции должно быть глаголом и выполняемым действием (showFirstMessage), есть функции без имени, это функции здесь и сейчас.
Параметры пишутся в круглых скобках - это данные (аргументы) для нашей функции, дальше в фигурных скобках пишутся разные действия.
Чтобы запустить функцию, ее надо вызвать командой (Например: showFirstMessage("");): 
        
        Пример:     function showFirstMessage (text) {
                        alert(text); 
                    }

                    showFirstMessage("Hello world");   

* Как ведут себя переменные в функциях? 
Если мы объявим переменную внутри функции, то видна она будет только внутри функции. Это называется локальная переменная.
Если задать перменные внутри функции и вне функции с одинаковым именем, то они все равно будут считаться разными переменными.

Когда внутри есть какое-то обращение к переменной, то сначала фукция ищет ее внутри себя, а лишь потом ищет ее вне функции. 

* Главная цель функции состоит в том, что мы вызываем ее по многу раз с разными параметрами.

        Пример простого калькулятора: 

        function calc(a,b) {
            return(a + b);
        }
        console.log(calc(3,4));
        console.log(calc(5,6));

* С помощью команды return можно выводить переменную из функции.

* Function Declaration - это значит, что функции работает еще до того как она объявлена в коде.
  Function Expression - это, когда мы присваиваем переменной функцию. 
        let calc = function(a,b) {
            return(a + b);
        }
  тут мы задали переменную как функцию, но в этом случае на данную функции не распространяется Function Declaration. То есть она
  задается только тогда, когда код до нее доходит и мы не можем вызвать ее до объявления как в предыдущем примере.

* В новом стандарте существует такое понятие как Стрелочная Функция:

        let calc = (a,b) => a + b;

Надо запомнить, что у стрелочных функций есть свои нюансы использования.

* Методы и свойства у строк и чисел.
Методы - это вспомогательные функции.
        let str = "test";

        console.log(str.toUpperCase());
        console.log(str.toLowerCase());

        Это пример метода, с его помощью мы мзменили саму строку.

Свойства - это вспомогатеьлные значения.

        let str = "test";
        console.log(str.length);

        Это пример свойства. С помощью length мы вывели длинну строки.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
///Методы и свойства строк и чисел

Полезные ссылки:
        1) Методы строк: https://learn.javascript.ru/string
        2) Методы чисел: https://learn.javascript.ru/number
        3) Документация по числам: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Number
        4) Документация по строкам: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/String


* Методы - это вспомогательные функции, а Свойства - это вспомогательные значения.

Методы - это вспомогательные функции.
        let str = "test";

        console.log(str.toUpperCase());
        console.log(str.toLowerCase());

        Это пример метода, с его помощью мы мзменили саму строку.

Свойства - это вспомогатеьлные значения.

        let str = "test";
        console.log(str.length);

        Это пример свойства. С помощью length мы вывели длинну строки.
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Callback-функции

Пример кода: 

        function first() {
            // Что-то делаем
            setTimeout( function(){
                console.log(1);
            }, 500 );
        }

        function second() {
            console.log(2); 
        }
        first();
        second();

В Output выведется 2 1 , а не 1 2. 

* Callback - функция, это функция которая будет выполнена только после того, как завершится другая функция.

Пример callback-функции: 

        function learnJS(lang, callback) {
            console.log("Я учу " + lang);
            callback();
        }

        function done() {
            console.log("Я прошел третий урок");
        }

        learnJS("JavaScript", done);

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Объекты, деструктуризация объектов (ES6)

Полезные ссылки:
        1) Деструктуризация объектов: https://learn.javascript.ru/destructuring#destrukturizatsiya-obekta
        2) Объекты JS в примерах: https://javascript.ru/tutorial/object/intro
        3) Дескрипторы, геттеры и сеттеры: https://learn.javascript.ru/descriptors-getters-setters
        4) Про for in: https://learn.javascript.ru/object-for-in

* Любой объект содержит пару ключ/значение
Пример объекта: 

        const options = {
            name: 'test',
            width: 1024,
            height: 1024,
            colors: {
                border: 'black',
                bg: 'red'
            }
        };

        console.log(options.name);

        delete options.name;

        console.log(options);

Последняя строка показывает то , что мы можем добавлять свойства в объект отдельной конструкцией.
* Часто можно встретить, что в объекте записаны другие объекты, это некий глобальный объект. Также можно удалять свойтсва из объекта
с помощью команды Delete.

* Для того, чтобы перебрать все свойства в объетке можно использовать цикл под названием ForIn
        Пример цикла ForIn:
                    for (let key in options) {
                        console.log(`Свойство + ${key} имеет значение ${options[key]}`);
                    }
        В скобках задаем переменную, которая обозначает все элементы объекта. Заданная переменная перебирает элементы объекта.

* Чтобы узнать колличество эллементов в объекте можно использовать следующую конструкцию: console.log(Object.keys(options).length);
* Также в объект можно записывать функции, тогда это метод объекта, а уже не свойство.
* В ES6 появилась новая особенность. Деструктуризация - это возможность вынести отдельные части объекта как отдельные структуры. 
        Пример: 
                const {border, bg} = options.colors;
                console.log(border);
        Данный пример показывает, как работает деструктуризация, в фигурные скобки мы записываем элементы объекта, затем после знака присваивания указываем путь до
        этих элементов в объекте. И в дальнейшем мы уже сможем обращаться к конкретным элементам объекта не прописывая весь путь внутри него. 
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Массивы и псевдомассивы 

* Полезные ссылки:
        1) Массивы: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Array
        2) Алгоритм быстрой сортировки: http://algolist.ru/sort/quick_sort.php
        3) Отличие for-of от for-in: http://coldfox.ru/article/5c7ffe64bbf20e61c12c7348/Отличие-for-of-от-for-in-в-javascript

* Массивы = это структуры, которые содержат элементы по порядку. Например набор функций, или массив со смешанными данными.
Пример массива: 

        let arr = [1, 2, 3, 4, 5];
        arr.pop();
        arr.push("5");
        console.log(arr);

Для того, чтобы удалить элемент с конца исопльзуем команду pop, а чтобы добавить элемент используем команду push.
Команда shift удаляет первыйй элемент массива, а команда unshift вставляет элемент в начало массива.

* Команда length возвращает не количество эллементов массива, а индекс последнего эллемента + 1.

* Как перебирать элементы?
            Пример кода:

            arr.forEach(function(item, i, arr){
                console.log(`${i}: ${item} внутри массива ${arr}`);
            });

            Данная конструкция перебирает все элементы массива и применяет к ним функцию. Первый аргумент - это тот элемент, который мы сейчас перебираем, назвать его можно
            как угодно, второй аргумент - это номер по порядку, третий аргумент - это ссылка на тот массив, который мы перебираем. 

* ForIn и ForOf

        let arr = [1, 3, 4, 6, 7];

        for (let key in arr){
            console.log(key);
        }
В данном коде с помощью for in мы перебираем ключи(индексы) элементов, а чтобы перебрать сами элементы используем не in, а of.

* Split и Join
Пример первого:

        let ans = prompt("", ""),
            arr = [];

        arr = ans.split(',');
        console.log(arr);

Тут мы используем команду split, в скобках пишем какой знак будет разделителем.

Пример второго:

        let arr = ["qwqwe", "ders", "ff", "ede"],
            i = arr.join(', ');

        console.log(i);
    
В данном примере мы используем команду join, для того чтобы взять элементы из массива и вывести их списком.
Также в этом примере мы можем использовать команду sort, чтобы она отсортировала элементы по алфавиту.

* Псевдомассив - это объект структура которого совпадает с обычными массивами, но у них нет тех же методов что у обычных массивов.

 
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
///Передача по ссылке или по значению, Spread оператор (ES6-ES9)

Полезные ссылки: 
        1) Статья про клонирование: https://medium.com/@stasonmars/копирование-объектов-в-javascript-d25c261a7aff
        2) Object.assign(): https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
        3) Spread operator: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Spread_syntax

* При работе с примитивными типами данных(строки, числа, логические значения), они передаются по значению, проще говоря, когда мы присваиваем одну переменную к другой, то 
идет присвоение не самой переменной, а ее значения.

* При работе со сложными типами данных, типа объекта, передача идет не по значению, а по ссылке, т.е. мы ссылаемся на объект, а не на саму его структуру.

* Тогда, чтобы копировать подобные типы данных, например, объект, мы используем другие методы, к примеру, через цикл. 

* При клонировании объектов надо запомнить два понятия: Глубокие и Поверхностные копии, в приведенном примере мы создаем поверхностную копию, т.к. она берет все обычные
свойства родителя и создает независимые структуры, но если есть вложенная структура, то это свойство опять будет иметь ссылочный тип данных. В примере в консоли мы увидим, 
что копирование объекта проходит правильно, но при взаимодействии с вложенной структурой, т.е. с объектом внутри объекта опять идетт ссылка, а не копирование.

Пример: 
        function copy(mainObj) {
            let objCopy = {};

            let key;
            for (key in mainObj) {
                objCopy[key] = mainObj[key];
            }

            return objCopy;
        }

        const numbers = {
            a: 2,
            b: 5,
            c: {
                x: 7,
                y: 4
            }
        };

        const newNumbers = copy(numbers);

        newNumbers.a = 10;
        newNumbers.c.x = 10;

        console.log(numbers);
        console.log(newNumbers);

* Второй способ копирования, через Object.assign();

Пример: 
        const add = {
            d: 17,
            e: 20
        };

        console.log(Object.assign(numbers, add));

    Данный код добавляем к предыдущему примеру, данная конструкция добавляет один объект к другому, первый аргумент - это то куда добавляем, второй - это то, что добавляем.
    Это независимая поверхностная копия. НО, можно вместо первого аргумента написать пустой объект, и таким образом можно копировать другой объект.

* Так же, есть способ копирования массива:
        const oldArray = ['a', 'b', 'c'];
        const newArray = oldArray.slice();

        newArray[1] = 'asdasd';
        console.log(newArray);
        console.log(oldArray);

* В новых стандартах еще появился оператор разворода (Spread, записывается в виде троеточия), который берет объект или массив и разворачивает его на отдельные элементы.
Пример 1:

        const video = ['youtube', 'vimeo', 'instagram'],
            blogs = ['wordpress', 'flipboard', 'blogger'],
            internet = [...video, ...blogs, 'vk', 'facebook'];

        console.log(internet);

Пример 2:

        function log(a, b, c) {
            console.log(a);
            console.log(b);
            console.log(c);
        }

        const num = [2, 5, 7];

        log(...num);

Пример 3, непосредственно показывает копирование при помощи этого метода: 

        const q = {
            one: 1,
            two: 2
        };

        const newObj = {...q};

        console.log(newObj);

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
///Объектно Ориентированное Программирование (ООП), прототипно-ориентированное наследование

Полезные ссылки: 
        1) Конструкторы, создание объектов через new: https://learn.javascript.ru/constructor-new
        2) Классы: https://learn.javascript.ru/classes
        3) Про __proto__: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Object/proto
        4) Наледование без __proto__: https://javascript.info/prototype-methods

* Теперь главную роль играют не функции, а объекты. ООП - простыми словами, у нас есть объект прототип, и изменяя его параметры, мы создаем новые объекты.
Например, прототип модельного окна, на основе которого мы создаем новые. Объект является прототипом для всего остального. Свойство _proto_ показывает 
некую иерархию.

* Установка прототипа: 

        const soldier = {
            health: 400,
            armor: 100
        };

        const John = {
            heakth: 100
        };

        // Устаревший формат 
        John.__proto__ = soldier;

        // Новый формат
        Object.setPrototypeOf(John, soldier);

* Более реальный пример, когда мы устанавливаем прототип на этапе создания объекта, а не в динамике:

        const John = Object.create(soldier);

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Работа с консолью разработчика. BreakPoints

* Иногда мы получаем ошибки, которые сложно найти в коде. Для того, чтобы остановить код в определеноом месте сущетсвует такое понятие как BreakPoint, нажимаем в консоли 
на номер нужной строки с кодом (или нескольккхи строк), код будет останавливаться на этих стрелках в коде.

* Кнопка Step into next function call переносит нас во внутрь функции, а не на следующую функцию. 

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Динамическая типизация в JS 

Полезные ссылки: 
    1) Статическая и динамическая типизация: https://habr.com/ru/post/308484/

* Типов данных 7 штук, они делятся на простые и комплексные (объекты). Числами мы определяем количественные данные. Булиновые типы данных (логические), то есть true и false.
Null это то, чего впринципе не существует. Undefined - это когда что-то сущетсвует, но не имеет никакого значения. 
* Комплексные типы данных (обычные и специальные). Объекты имеют свойства и методы(их функции). Массивы это специальные объекты с оперделенным синтаксисом. В объекте мы пишем
пару ключ/значение, а в массивах ключи у нас преобразуются в индексы, т.е. их номера, следовательно массивы - это частные случаи объектов.

* Динамическая типизация - это возможность одних типов данных становиться другими типами данных. 

* Конкатенация - ее можно использовать например для задания URL адреса, т.е. в виде строки записать начало адреса страницы, а дальше при помощи JS добавить еще какое-то 
значение в продолжение адреса.

* Чтобы поменять любой тип данных в число, достаточно поставить перед этими данными унарный плюс.

* 0, '', null, undefined, NaN - это все всегда будет как False.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
///Задачи с собеседований на понимание основ

Некоторые вопросы: 
        •	Какое будет выведено значение: let x = 5; alert( x++ ); ?  //5

        •	Чему равно такое выражение: [ ] + false - null + true ?   //Nan

        •	Что выведет этот код: let y = 1; let x = y = 2; alert(x); ?   //2

        •	Чему равна сумма [ ] + 1 + 2?   //12

        •	Что выведет этот код: alert( "1"[0] )?   //1

        •	Чему равно 2 && 1 && null && 0 && undefined ?   //null

        •	Есть ли разница между выражениями? !!( a && b ) и (a && b)?   //да

        •	Что выведет этот код: alert( null || 2 && 3 || 4 ); ?   //3

        •	a = [1, 2, 3]; b = [1, 2, 3]; Правда ли что a == b ?   //нет

        •	Что выведет этот код: alert( +"Infinity" ); ?   //Infinity

        •	Верно ли сравнение: "Ёжик" > "яблоко"?   //нет

        •	Чему равно 0 || "" || 2 || undefined || true || falsе ?   //true

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Получение элементов со страницы

Полезные ссылки:
                1) Про селекторы: https://learn.javascript.ru/css-selectors
                2) О псевдомассивах: https://habr.com/ru/post/336136/
                
Способы получения элементов:
    1) Через ID: document.getElementById
    2) Через теги: document.getElementsByTagName 
    3) Через класс: document.getElementsByClassName 
Получение элемента через ID предполагает, что все ID уникальные, а другие способы этого не предполагают. Во втором случае речь идет о псевдомассивах.

    4) Через селектор: document.querySelectorAll , а также document.querySelector
При получении элемента через селектор надо выбрать правильный селектор, будь то класс, тег, и т.д. (для класса ставим точку, для ID ставим #, для атрибута [], ...). 
Второй способ из примера выбирает только первый элемент с селектором, который он найдет.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Действия с элементами на странице 

    см. файл script.js 

Методы для поиска элементов:
    1) getElementsByTagName - собирает все элементы с заданным тегом 
    2) getElementbyId - находит элемент с конкретным ID
    3) getElementsByClassName - находит жлементы с заданным классом

Методы для изменения документа: 
    1) removeChild - удаляет заданный дочерний узел
    2) replaceChild - заменяет один дочерний узел другим (заменяемый узел должен быть дочерним узлом того элемента, чей метод мы вызываем)
    2) appendChild - добавление узла в конец списка
    3) insertBefore - добавляет узел (первый аргумент) перед нужным узлом (второй аргумент)

    4) document.createTextNode - добавление новых текстовых узлов 
    5) document.createElement - метод принимает имя тега и возвращает новый пустой узел заданного типа.


Примеры подразумевают эту структуру:
        const box = document.getElementById('box'),
              btns = document.getElementsByTagName('button'),
              circles = document.getElementsByClassName('circle'),
              wrapper = document.querySelector('.wrapper'),
              hearts = wrapper.querySelectorAll('.heart'),
              oneHeart = wrapper.querySelector('.heart');

* Чтобы создать новый элемент внутри JS файла
        const div = document.createElement('div');

* Чтобы создать новый класс
        div.classList.add('black'); 

* Чтобы добавить элемент в конец какой-то структуры:
        document.querySelector('.wrapper').append(div);

* Чтобы добавить элемент в начало какой-то структуры:
        document.querySelector('.wrapper').prepend(div);

* Чтобы вставить перед первым указанным элементом:
        hearts[0].before(div);

* Чтобы вставить после первого указанного элемента:
        hearts[0].after(div);
    
* Чтобы удалить элемент:
        circles[0].remove();

* Чтобы заменить первый указанный элемент вторым указанным элементом:
        hearts[0].replaceWith(circles[0]);

* Указанные выше методы, но в устаревшем формате:
        wrapper.insertBefore(div, hearts[2]);
        wrapper.removeChild(hearts[1]);
        wrapper.replaceChild(circles[0], hearts[0]);

* Втсавка HTML-элемента:
        div.innerHTML = '<h1>Hello world</h1>';

* Вставка текста, а не элемента, чтобы пользователь не смог поломать нам структуру:
        div.textContent = 'hello';

* вставка HTML-элемента перед самым первым указанным аргументом:
        div.insertAdjacentHTML('beforebegin', '<h2>Hello</h2>');

* вставка HTML-элемента в начало самого первого указанного аргументом:
        div.insertAdjacentHTML('afterbegin', '<h2>Hello</h2>');

* вставка HTML-элемента в в конец самого первого указанного аргументом:
        div.insertAdjacentHTML('beforeend', '<h2>Hello</h2>');

* вставка HTML-элемента после самого первого указанного аргументом:
        div.insertAdjacentHTML('afterend', '<h2>Hello</h2>');


___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// События и их обработчики
Полезные ссылки: 
    1) Браузерные события: https://learn.javascript.ru/introduction-browser-events
    2) Метод EventTarget.addEventListener(): https://developer.mozilla.org/ru/docs/Web/API/EventTarget/addEventListener
    3) Даты в JS: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date
    4) Про disabled: https://www.w3schools.com/tags/att_disabled.asp
    5) Простой список событий: https://oddler.ru/blog/i63
    6) Справочнико по событиям: https://developer.mozilla.org/ru/docs/Web/Events
    7) Объект события: https://developer.mozilla.org/ru/docs/Web/API/Event
    8) Метод EventTarget.removeEventListener(): https://developer.mozilla.org/ru/docs/Web/API/EventTarget/removeEventListener

* Событие - это сигнал от браузера что что-то произошло. 
* Обработчик события - это функция, которая срабатывает как только событие произошло. 

Способы назначения обработчика событий:
    1) Использовать атрибут html 
    Он используется для самых маленьких скриптов, и в целом его использование не рекомендуется.
    \\ <button id="btn" onclick="alert('Вы нажали первую кнопку')">Нажми меня</button> \\

    2) Использовать свойства DOM для событий: 
    При использовани данного способа мы можем назначить лишь одну функцию на один элемент. То есть более новая функция заменяет старую.

            const button = document.querySelector('button');

            button.onclick = function() {
                alert('Click');
            };

    3) Использовать методы addEventListener и removeEventListener:
    Данный способ решает проблему из предыдущего способа задачи обработчика событий 

            button.addEventListener('mouseenter', (event) => {
                console.log(event.target);
                event.target.remove();
            });
    

* Для того, чтобы отменить некоторые действия браузера можно использовать команду preventDefault.

* Как правильно устанавливать один обработчик события для нескольких элементов: использовать метод forEach

* Свойство target показывает тот элемент, который используется обработчиком событий. 

* Всплытие событий - когда действие сначала срабатывает на вложенном элемете, а лишь потом на родительском. Например, когда для таких элементов используется один и тот же 
  обработчик событий.


* Чтобы отменить станлартное поведение браузера, например, чтобы при клике на мышке не было перехода по ней, иожно использовать данный метод (preventDefault) обработчика событий:

            const link = document.querySelector('a');

            link.addEventListener('click', function(event) {
                event.preventDefault();

                console.log(event.target);
            });


* Для того чтобы навесить один обработчик событий на несколько элеметов сразу, необходимо перебрать все элементы псевдомассива и назначить им этот обработчик.

            btns.forEach(btn => {
                btn.addEventListener('click', deleteElement);
            });

так же см ScrapPaper (строки: 353 - 389);
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Навигация по DOM - элементам, data-атрибуты, преимущество for/of
Полезные ссылки: 
    1) Про data-атрибуты: https://developer.mozilla.org/ru/docs/Web/Guide/HTML/Using_data_attributes

* Различные методы работы с элеметами на странице:

    console.log(document.head);
    console.log(document.documentElement);
    console.log(document.body.childNodes);
    console.log(document.body.firstChild);
    console.log(document.body.firstElementChild);
    console.log(document.body.lastChild);
    console.log(document.body.lastElementChild);

    console.log(document.querySelector('#current').parentNode.parentNode);
    console.log(document.querySelector('#current').parentNode.parentElement);


    console.log(document.querySelector('[data-current="3"]').nextSibling);
    console.log(document.querySelector('[data-current="3"]').nextElementSibling);

* Конструкция для перебора всех нод, исключая текстовые ноды, которые не видны в коде:
            for (let node of document.body.childNodes) {
                if (node.nodeName == '#text') {
                    continue;
                }

                console.log(node);
            };


___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// События на мобильных устройствах
Полезные ссылки:
    1) Большая статья с примерами: http://youon.ru/Андроид/Разработка/touch-sobytiya-na-javascript-multitach-realizatsiya
    2) Статья: https://habr.com/ru/company/sibirix/blog/227175/

* На мобильных устройствах вместо кликов у нас тапы, но чаще всего мобильные браузеры сами могут все поддерживать.
* Всего 6 мобильных событий:

* Список событий, которые используются для мобиьлных браузеров:
        touchstart, когда произошло касание к элементу
        touchmove, когда палец при косании начинает двигаться по элементу
        touchend, когда палец оторвался от элемента
        touchenter, когда ведем пальцем и он заскользил на элемент
        touchleave, когда палец ушел за пределы элемента
        touchcancel, когда точка соприкосновения больше не регистрируется брауером 

        Пример кода: 
            window.addEventListener('DOMContentLoaded', () => {
                const box = document.querySelector('.box');

                box.addEventListener('touchstart', (e) => {
                    e.preventDefault();

                    console.log('Start');
                    console.log(e.targetTouches);
                });

                box.addEventListener('touchmove', (e) => {
                    e.preventDefault();

                    console.log(e.targetTouches[0].pageX); // показывает координаты пальца в динамике
                });

                box.addEventListener('touchend', (e) => {
                    e.preventDefault();

                    console.log('End');
                });
            });

* Несколько свойств: 
        touches свойство, которое выдает список всех пальцев, которыми тапнут экран
        targetTouches свойство, которое показывает все пальцы, которые взаимодействую с конкретным элементом
        changedTouches свойсвто, которое показывает список пальцев, учавствующих в текущем событии, даже если они были убраны

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Async, defer, динамические скрипты

* Атрибут deffer, во-первых, загружает скрипт в фоновом режиме, во-вторых, запускает скрипт, только после завершение построения DOM-структуры.
Пример:
        <script defer src="js/script.js"></script>  // Запись в HTML

Это используется, когда скрипт записан не в конце HTML-документа, внутри. Также, если у нас несколько ссылок на скрипты с атрибутами deffer, то и загружаться они будут
по очереди, а не в зависимости от скорости выполнения. То есть, если сначала большой скрипт, а потом маленький, то все равно сначала будет загружен первый.
Этот атрибут нужен для контроля порядка выполнения всех подключенных утилит. 

* Атрибут async, во-первых, загружается в фоновом режиме, во-вторых, выполняется по завершению загрузки и не ждет завершения других процессов. То есть, скрипт с async 
не ждет других скриптов, и другие скрипты тоже не ждут скрипт с async.

Если несколько скриптов с этим артибутом, то они выполняются тоже по мере загрузки, в зависимости от размера. Например, когда у нас есть сторонние скрипты, которые 
не так значимы как самые основные.

Пример:
        <script async src="js/script.js"></script>  // Запись в HTML

* Про работу со скриптами внутри JS. 
        const script = document.createElement('script');
        script.src = "js/test.js";
        document.body.append(script);

        Это динамически загружаемый скрипт, который внутри основного скрипта, работает как скрипт с атрибутом async. Это можно обойти добавив такую конструкцию в этот скрипт:
                script.async = false;
                
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// ClassList и делегирование событий 

Полезные ссылки: 
    1) classList: https://developer.mozilla.org/ru/docs/Web/API/Element/classList
    2) matches: https://developer.mozilla.org/ru/docs/Web/API/Element/matches
    3) Делегирование событий 1: https://learn.javascript.ru/event-delegation
    4) Делегирование событий 2: https://medium.com/@stasonmars/делегирование-событий-в-javascript-d91cbdd8916a

* Создаем переменную, которая через селектор находит все 'button', затем в консоль выводим количество классов для этих кнопок, а затем конкретный класс
под нулевым индексом, затем с помощью add добавляем первой кнопке новый класс red, затем с помощью remove удаляем у первой кнопки класс blue. С помощью
toggle мы либо добавляем новый класс, если до этого его не было, либо удаляем, если до этого он уже присутствовал (переключатель). В add и remove можно
использовать несколько классов, записывая их через запятую. Далее, используя contains в условии, мы проверяем наличие конкретного класса у элемента,
данная конструкция возвращает булиновое значение и затем, если true, выполняет дейсвтие. 

    const btns = document.querySelectorAll('button');

    console.log(btns[0].classList.length);
    console.log(btns[0].classList.item(0));
    console.log(btns[0].classList.add('red'));
    console.log(btns[0].classList.remove('blue'));
    console.log(btns[0].classList.toggle('blue'));

    if (btns[1].classList.contains('red')) {
    console.log('red');
    }

* Здесь при клике на первый button начианется проверка, если у второго button нет класса red, то добавляем его, иначе, просто удаляем класс red.
Данная конструкция работает так же как toggle, однако иногда приходится использовать полную схему, а не просто toggle. 

    btns[0].addEventListener('click', () => {
    if (!btns[1].classList.contains('red')) {
        btns[1].classList.add('red');
    } else {
        btns[1].classList.remove('red');
    }
    }); 

* Делегирование событий - например, мы назначаем обработчик событий на родительский элемент, а функцию мы назначаем для его потомков при соблюдении ими
каких-то условий. 

* Добавляем переменную wrapper, которая является родителем для всех кнопок, далее, с помощью console.dir мы узнали, что button имеет tagName 'BUTTON',
далее через условие проверяем, что при клике есть event.target и taagName у event.target это 'BUTTON', проверяем через && потому что, есть элементы
у которых нет события клика, именно для этого идет проверка на существование event.target. В следующем примере вывод в консоль будет только при клике
на кнопку с классом blue. Далее мы динамически добавляем новый элемент и так же пробуем тоже самое действие, но через перебор forEach и видим, что 
применяя forEach дейсвтие происходит только на изначальных элементах, а при делегировании новые элементы также задействуются. 

    const btns = document.querySelectorAll('button'),
          wrapper = document.querySelector('.btn-block');
    
    wrapper.addEventListener('click', (event) => {
        console.dir(event.target);
    });

    wrapper.addEventListener('click', (event) => {
        if (event.target && event.target.tagName == "BUTTON") {
            console.log('Hello');
        }
    });

    wrapper.addEventListener('click', (event) => {
        if (event.target && event.target.classList.contains('blue')) {
            console.log('Hello');
        }
    });

    btns.forEach(btn => {
        btn.addEventListener('click', () => {
            console.log('Hello');
        });
    });

    const btn = document.createElement('button');
    btn.classList.add('red');
    wrapper.append(btn);

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Скрипты и время их выполнения. setTimeout и setInterval

Полезные ссылки: 
    1) JavaScript-анимации: https://learn.javascript.ru/js-animation


* С помощью setTimeout запускаем операцию с задержкой.

    const timerId = setTimeout(function() {
        console.log('Hello');
    }, 2000);

* Похожий пример, с помощью clearInterval сбрасываем отложеную команду. 

    const timerId = setTimeout(logger, 2000);

    clearInterval(timerId);

    function logger () {
        console.log('text');
    }

* В данном примере: задаем переменную - кнопку на сайте, задаем остальные переменные, создаем обработчик событий на нажатие нашей кнопки, 
внутри записав функцию, которая с заданным интервалом вызывает функцию logger, эта функция выдает в консоль 'text' до тех пор пока итератор
не будет больше 3 и затем обрывает интервал. 

    const btn = document.querySelector('.btn');
    let timerId,
        i = 0;

    btn.addEventListener('click', () => {
        // const timerId = setTimeout(logger, 2000);
        timerId = setInterval(logger, 2000);
    });


    function logger () {
        if (i === 3) {
            clearInterval(timerId);
        }
        console.log('text');
        i++;
    }


* В данном примере код двигает коробку из верхнего левого угла в правый нижний попиксельно. 

    const btn = document.querySelector('.btn');
    let timerId,
        i = 0;

    function myAnimation() {
        const element = document.querySelector('.box');
        let pos = 0;

        const id = setInterval(frame, 100);
        function frame() {
            if (pos == 300) {
                clearInterval(id);
            } else { 
                pos++;
                element.style.top = pos + "px";
                element.style.left = pos + "px"; 
            }
        }
    }

    btn.addEventListener('click', myAnimation);

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Работа с датами

Полезные ссылки:
    1) Дата и время: https://learn.javascript.ru/date
    2) Дата: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date

* Определяем текущее время, далее выводиться текущий год, текущий месяц и текущий день итд. Далее разница между нашим временем 
и UTC. Затем получаем количество милисекунд с начала 1970 года. 

    const now = new Date();

    console.log(now.getFullYear());
    console.log(now.getMonth());
    console.log(now.getDate());

    console.log(now.getTimezoneOffset());
    console.log(now.getTime());

* Пример отсчета времени выполнения кода

    let start = new Date();

    for (let i = 0; i < 100000; i++) {
        let some = i **3;
    }

    let end = new Date();
    console.log(`Цикл отработал за ${end - start} милисекунд`);

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Параметры документа, окна и работа с ними

 см. Metric-all.png

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Функции-конструкторы

Полезные ссылки: 
    1) Функции-конструкторы: https://learn.javascript.ru/constructor-new

    * Создаем функцию-консруктор, с помощью new мы создаем уже не функцию, а создаем объект с указанными свойствами,
    с помощью prototype мы можем добавлять новые методы или свойства в наш конструктор и они будут прототипно наследоваться
    у потомков, это используется когда у нас нет доступа к прототипу или нам нельзя его менять по каким-то причинам.  

            function User(name, id) {
                this.name = name;
                this.id = id;
                this.human = true;
                this.hello = function() {
                    console.log(`Hello ${this.name}`);
                };
            }

            User.prototype.exit = function(name) {
                console.log(`User ${this.name} left`);
            };

            const ivan = new User('Ivan', 28);
            const alex = new User('Alex', 20);

            ivan.exit();

            ivan.hello();
            alex.hello();
    
    * Конструкторы необходимы для создания новых однотипных объектов (новые пользователи, товары в магазине, компоненты сайта итд). Все это 
    стандарты ES5, в ES6 у нас появляются классы.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Контекст вызова. This

Полезные ссылки: 
    1) Большой гайд по this: https://tproger.ru/translations/javascript-this-keyword/

    * 

    * Функции вызываются 4 способами:

        1) Обычная функция: this = ссылается на глобальный объект window, но если use strict - undefined

            function showThis() {
                console.log(this);
            }
            showThis();

        2) Контекст у методов объекста - сам объект (Если мы используем метод внутри объекта, то контекст вызова будет ссылаться на этот объект)

            const obj = {
                a: 20,
                b: 15,
                sum: function() {
                    console.log(this);
                }
            };
            obj.sum();

        3) this в конструкторах и классах - ссылается на новый экземпляр объекта

            function User(name, id) {
                this.name = name;
                this.id = id;
                this.human = true;
                this.hello = function() {
                    console.log(`Hello ${this.name}`);
                };
            }
            const ivan = new User('Ivan', 28); 

        4) Ручная привязка this: call, apply, bind

            Использование методов позволяет переввести контекст вызова на нужный объект.

            function sayName(surname) {
                console.log(this);
                console.log(this.name + surname);

            }

            const user = {
                name: 'John'
            };

            // Дальше показывается разница синтаксиса двух идентичных методов, при передаче новой переменной.
            sayName.call(user, ' Smith'); 
            sayName.apply(user, [' Smith']);

            function count(num) {
                return this*num;
            }

            const double = count.bind(2);
            console.log(double(3));  // 6
            console.log(double(13));  // 26

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Классы (ES6)

Полезные ссылки: 
    1) Документация по классам: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Classes
    2) Статья по классам: http://jsraccoon.ru/es6-classes

    * Классы - это красивая обертка функций-конструкторов (синтаксический сахар), создание шаблона для создания однородных компонентов с некими различиями.

            class Rectangle {
                constructor(height, width) {
                    this.height = height;
                    this.width = width;
                }

                calcArea() {
                    return this.height*this.width;
                }
            }

            class ColoredRectangleWithText extends Rectangle {  // extends - новый класс наследуется от указанного
                constructor(height, width, text, bgColor) {
                    super(height, width); // Вызывает тоже самое что у родителя (всегда нужно ставить на первое место)
                    this.text = text;
                    this.bgColor = bgColor;
                }

                showMyProps() {
                    console.log(`Текст: ${this.text}, Цвет: ${this.bgColor}`);
                }
            }

            const div = new ColoredRectangleWithText(25, 10, 'Hello world', 'red');
            div.showMyProps();
            console.log(div.calcArea());

    * Принципы ООП:
        1) Абстракция - отделение экзмепляра от концепции.
        2) Наследование - способность нашего объекта или класса базироваться на основе другого объекта или класса. 

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Rest оператор и параметры по умолчанию (ES6)

Полезные ссылки: 
    1) rest: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Rest_parameters
    2) Параметры по умолчанию: https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Default_parameters

    * Оператор разворота (спред оператор мы уже прошли), rest берет отдельные элементы и объединяет их в массив. 

        const log = function(a, b, ...rest) {
            console.log(a, b, rest);
        };

        log('basic', 'rest', 'operator', 'usage' );

    * Параметры по умолчанию:

        function calcOrDouble(number, basis = 2) {  // Приравниваем аргумент в условии, чтобы задать параметр по умолчанию
            basis = basis || 2; // Запишется 2 если аргумента нет, это старый способ и больше не используется см выше
            console.log(number * basis);
        }
        calcOrDouble(3, 5);


___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Локальные сервера

Полезные ссылки: 
    1) MAMP: https://www.mamp.info/ru/
    2) OpenServer: https://ospanel.io/

    * Как работают сервера: 

        Например у хостера всегда включен сервер и мы этим можем пользоваться, можно запускать локальные сервера. 
        Есть простые локальные сервера (например LiveServer).

        HTTP запросы: get (запрос на получение данных с сервера), post (запрос на отправку данных на сервер).
        Простые(малые) сервера умеют обрабатывать только get-запросы. 


___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// JSON формат передачи данных, глубокое клонирование объектов

* Маленький вес и простота чтения (почему JSON)

Полезные ссылки: 
    1) Клонирование объектов: https://medium.com/@stasonmars/копирование-объектов-в-javascript-d25c261a7aff
    2) HTTP: https://ru.wikipedia.org/wiki/HTTP
    3) JSON: https://ru.wikipedia.org/wiki/JSON
    

    * Передаем на сервер объект в JSON формате
        const person = {
            name: 'Alex',
            tel: '+75555555555'
        };

        console.log(JSON.stringify(person));

    * Получаем с сервер объект в JSON формате и преобразуем в обычный
        const person = {
            name: 'Alex',
            tel: '+75555555555'
        };

        console.log(JSON.parse(JSON.stringify(person)));

    * Пример глубокого клонирования
        const person = {
            name: 'Alex',
            tel: '+75555555555',
            parents: {
                mom: 'Hina',
                dad: 'Mike'
            }
        };

        const clone = JSON.parse(JSON.stringify(person));
        clone.parents.mom = 'Yumiko';
        console.log(person);
        console.log(clone);

        \\output\\
            {
            name: 'Alex',
            tel: '+75555555555',
            parents: { mom: 'Hina', dad: 'Mike' }
            }
            {
            name: 'Alex',
            tel: '+75555555555',
            parents: { mom: 'Yumiko', dad: 'Mike' }
            }


___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// AJAX и общение с сервером 
    
Полезные ссылки: 
    1) XMLHttpRequest: https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest
    2) Использование XMLHttpRequest: https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest
    3) Объект FormData: https://developer.mozilla.org/ru/docs/Web/API/FormData/Using_FormData_Objects
    4) CONVERT FORMDATA TO JSON: https://ilikekillnerds.com/2017/09/convert-formdata-json-object/
    5) Заголовки HTTP: https://ru.wikipedia.org/wiki/Заголовки_HTTP
    6) Список кодов состояния HTTP: https://ru.wikipedia.org/wiki/Список_кодов_состояния_HTTP
    7) XMLHttpRequest.readyState: https://developer.mozilla.org/ru/docs/Web/API/XMLHttpRequest/readyState

* Асинхронная подгрузка контента, то есть при определенных запросах у нас не перезагружается весь сайт, а происходит подгрузка
* Чтобы front-end часть могла общаться с сервером нужны http запросы 



const inputRub = document.querySelector('#rub'),
    inputUsd = document.querySelector('#usd');

// Вместо события input также можно испольщзовать событие change, оно срабатывает при изменнеии фокуса, 
// например если вбить инпут и нажать таб, а событие input срабатывает непосредственно при вводе изменений
inputRub.addEventListener('input', () => {
    const request = new XMLHttpRequest();

    // request.open(method, url, async, login, password);
    // open собирает настройки для будущего запроса (метод запроса, путь запроса, синх/асинх, ...)
    // GET - метод запроса данных с сервера, POST - метод ввода данных на сервер 
    request.open('GET', 'js/current.json');
    // HTTP заголовол для опредления того, что передается 
    request.setRequestHeader('Content-type', 'application-json; charset=utf-8');
    // Отправка запроса
    request.send();

    request.addEventListener('readystatechange', () => {
        if (request.readyState === 4 && request.status === 200) {
            console.log(request.response);
            const data = JSON.parse(request.response);
            inputUsd.value = (+inputRub.value / data.current.usd).toFixed(2);
        } else {
            inputUsd.value = "Попробуйте чуть позже";
        }
    });

    // *Свойства* 
    // status 
    // statusText
    // response
    // readyState 
});

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Реализация скрипта отправки данных на сервер

См. практическую часть 


___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Красивое оповещение пользователя 



        1-2% для крипты (0,01-0,02)
        0,1-0,2% для фонды (0,001-0,002)

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Fetch API 

    fetch('https://jsonplaceholder.typicode.com/todos/1')
        .then(response => response.json())
        .then(json => console.log(json));

Fetch использует промисы, первая конструкция fetch возвращает промис, а при его возвращении мы можем его обрабатывать с помощью цепочки .then. Вторая строка это получение ответа в формате json. Чтобы дальше его использовать метод трансформирует json формат в подходяищй для использования в js объект. А следующая строка это уже использование полученного и трансформированного объекта. Первый пример показывает GET запрос. 

    fetch('https://jsonplaceholder.typicode.com/posts', {
        method: "POST",
        body: JSON,stringify({name: 'Alex'})  // В этой строке пожно поместить как строку, так и объект
        headers: {
            'Content-type': 'application/json'
        }
    })
        .then(response => response.json())
        .then(json => console.log(json));
        
Второй пример это Fetch запрос POST для отправки данных с клиента на сервер.
Fetch API - намного более легкий способ общения с сервером, чем стоковый XMLhttpRequest.

По дефолту reject отрабатывает при сбое сети, т.е. если выдаст код ошибки 404 это не будет идти в catch.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
/// Методы перебора массива 

* filter - метод forEach просто перебирает массив и не возвращает новый, а filter, map, ... они создают новый массив. В этот массив передается callback функция.

    const names = ['Ivan','Anna','Ksenia','Voldemart'];

    const shortNames = names.filter(function(name){
        return name.length < 5; // Тут можно через if или через такую запись 
    });

* map - берет исходный массив и изменяет каждый элемент согласно заданному условию и создает на этой основе новый массив.

    const answers = ['IvAn','AnnA','Hello'];

    const result = answers.map(item => {
        return item.toLowerCase();
    });

    или 

    const result = answers.map(item => item.toLowerCase());

необязательно создавать новый массив, можно просто перезаписать старый массив, но нужно поменять const на let, но это плохая практика, лучше создавать новый массив.

* every/some - перебирают массив и при совпадении возвращают true или false. При Some нужно одно совпадение, при Every при совпадении с условием всех элементов.

    const arr = [4, 5, 7];
    console.log(arr.every(item => typeof(item) === 'number'));
    // true 

* reduce - меотд перебора, проходящий по каждому элементу, и выдающий(схлопывающий) массив в одно значение после применения заданного условия. Принимает два аргумента, которые подставляются автоматически, первый это сумма всех элементов, второй это текущий элемент в цикле. Также принимает еще необязательный аргумент, который подставляется как начальное значние см. пример 1.

    const arr =[4, 5, 1, 3, 2, 6];
    const res = arr.reduce((sum, current) => sum + current, 3);
    //24

    const arr = ['apple', 'pear', 'plum'];
    const res = arr.reduce((sum, current) => `${sum}, ${current}`);
    //apple, pear, plum

* entries - метод объектов, который переводит объект в матрицу массивов (массив массивов). 

    const obj = {
        ivan: 'persone',
        ann: 'persone',
        dog: 'animal',
        cat: 'animal'
    }

    const newArr = Object.entries(obj)
    .filter(item => item[1] === 'persone')
    // [ [ 'ivan', 'persone' ], [ 'ann', 'persone' ] ]
    .map(item => item[0]);
    // [ 'ivan', 'ann' ]

    В этом примере c .filter мы выбираем второй элемент массива, так как точно знаем что в массивах, которые находятся в матрице массивов, второй элемент это нужное нам для проверки значение. А с .map мы берем первый элемент из полученных нами массивов, и записываем их в новый результирующий массив.

___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
___________________________________________________________________________________________________________________________________________________________________________
///